// GP4U Platform — Complete Prisma Schema
// Includes all Custodes fields, Obsidian ledger, and chamber support.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Enums ────────────────────────────────────────────────────────────────────

enum Provider {
  AWS
  GCP
  AZURE
  LAMBDA
  RUNPOD
  OTHER
}

enum GPUStatus {
  AVAILABLE
  BUSY
  LIMITED
  OFFLINE
}

enum JobStatus {
  PENDING
  RUNNING
  COMPLETE
  FAILED
}

enum SupplyTier {
  BACKBONE
  CAMPUS
  EDGE
}

enum SubjectType {
  HUMAN
  AGENT
  INSTITUTION
  SERVICE
}

enum ClearanceLevel {
  EMAIL_ONLY    // 0
  INSTITUTIONAL // 1
  ENTERPRISE    // 2
  ADMIN         // 3
}

enum DisputeStatus {
  OPEN
  UNDER_REVIEW
  RESOLVED
  DISMISSED
}

enum ChamberMode {
  PASSIVE
  BACKTEST
  ACTIVE
  OFFLINE
}

// ─── Core: Users (extended with Custodes fields) ──────────────────────────────

model User {
  id                String         @id @default(cuid())
  email             String         @unique
  name              String?

  // Custodes Dextera fields
  subject_type      SubjectType    @default(HUMAN)
  clearance_level   Int            @default(0)
  trust_score       Float          @default(0)
  is_banned         Boolean        @default(false)
  ban_reason        String?
  identity_provider String         @default("EMAIL_PASSWORD")
  institution_id    String?
  org_id            String?

  createdAt         DateTime       @default(now())
  updatedAt         DateTime       @updatedAt

  jobs              Job[]
  auth_events       AuthEvent[]
  memory_stakes     MemoryStake[]

  @@index([email])
  @@index([institution_id])
}

// ─── Core: GPUs (extended with Atlas + health fields) ─────────────────────────

model GPU {
  id                     String     @id @default(cuid())
  name                   String
  provider               Provider
  vramGB                 Int
  pricePerHour           Decimal    @db.Decimal(10, 4)
  region                 String
  status                 GPUStatus  @default(AVAILABLE)

  // Atlas fields
  supply_tier            SupplyTier @default(EDGE)
  node_id                String?
  vram_available_gb      Int?
  trust_score            Float      @default(0)
  veritas_verified       Boolean    @default(false)
  benchmark_score        Int?
  allowed_workload_types String     @default("TRAINING,INFERENCE")
  price_mode             String     @default("FIXED")
  power_cap_watts        Int?

  createdAt              DateTime   @default(now())
  updatedAt              DateTime   @updatedAt

  health                 GPUHealth?
  jobs                   Job[]
  memory_stakes          MemoryStake[]

  @@index([provider])
  @@index([region])
  @@index([supply_tier])
  @@index([status])
}

model GPUHealth {
  id                String   @id @default(cuid())
  gpuId             String   @unique
  thermalScore      Int
  memoryScore       Int
  uptimeHours       Int
  lastMaintenanceAt DateTime
  pastUsageTags     String

  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  gpu               GPU      @relation(fields: [gpuId], references: [id], onDelete: Cascade)
}

// ─── Core: Jobs (extended with Atlas allocation + Russian-Doll fields) ────────

model Job {
  id                    String    @id @default(cuid())
  userId                String
  gpuId                 String
  name                  String
  status                JobStatus @default(PENDING)
  expectedDurationHours Decimal   @db.Decimal(10, 2)
  costEstimate          Decimal   @db.Decimal(10, 2)
  scriptPath            String?

  // Atlas allocation fields
  allocation_id         String?
  supply_tier           String?
  routing_score         Float?
  actual_cost           Decimal?  @db.Decimal(10, 4)
  workload_type         String    @default("TRAINING")

  // Russian-Doll telemetry
  energy_kwh            Float?
  carbon_kg_co2e        Float?
  virtual_transistors   BigInt?
  energy_per_op_fj      Float?

  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  user                  User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  gpu                   GPU       @relation(fields: [gpuId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([gpuId])
  @@index([status])
  @@index([allocation_id])
}

// ─── Arbitrage Snapshots ──────────────────────────────────────────────────────

model ArbitrageSnapshot {
  id            String   @id @default(cuid())
  gpuType       String
  numGpus       Int
  durationHours Decimal  @db.Decimal(10, 2)
  provider      Provider
  pricePerHour  Decimal  @db.Decimal(10, 4)
  totalCost     Decimal  @db.Decimal(10, 2)
  createdAt     DateTime @default(now())

  @@index([gpuType])
  @@index([provider])
  @@index([createdAt])
}

// ─── Memory Staking (Mnemo Chamber) ──────────────────────────────────────────

model MemoryStake {
  id                    String   @id @default(cuid())
  userId                String
  gpuId                 String
  vram_gb               Int
  ram_gb                Int
  asking_price_per_gb_sec Decimal @db.Decimal(18, 10)
  idle_schedule         String?  // JSON cron expression
  is_active             Boolean  @default(true)
  total_earned_usd      Decimal  @default(0) @db.Decimal(10, 4)
  allocation_count      Int      @default(0)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  gpu                   GPU      @relation(fields: [gpuId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([gpuId])
  @@index([is_active])
}

// ─── Obsidian: Immutable Ledger ───────────────────────────────────────────────

model LedgerEntry {
  id              String   @id @default(cuid())
  entry_id        String   @unique
  block_index     Int      @unique
  event_type      String
  severity        String   @default("INFO")
  subject_id      String?
  passport_id     String?
  institution_id  String?
  target_id       String?
  target_type     String?
  metadata        Json?
  ip_address_hash String?
  region          String?
  timestamp       DateTime
  sequence        Int
  prev_hash       String
  payload_hash    String
  block_hash      String
  merkle_root     String?
  created_at      DateTime @default(now())

  @@index([event_type])
  @@index([subject_id])
  @@index([target_id])
  @@index([block_index])
  @@index([timestamp])
}

model MerkleBlock {
  id           String   @id @default(cuid())
  block_number Int      @unique
  merkle_root  String
  entry_count  Int
  first_index  Int
  last_index   Int
  sealed_at    DateTime
  signature    String
  sealed_by    String

  @@index([block_number])
}

model Dispute {
  id                 String        @id @default(cuid())
  dispute_id         String        @unique
  job_id             String
  opened_by          String
  against            String
  reason             String
  status             DisputeStatus @default(OPEN)
  outcome            String?
  resolved_by        String?
  resolution_notes   String?
  refund_amount      Decimal?      @db.Decimal(10, 2)
  evidence_entry_ids Json          @default("[]")
  opened_at          DateTime      @default(now())
  resolved_at        DateTime?

  @@index([job_id])
  @@index([status])
  @@index([opened_by])
}

// ─── Dextera: Auth Events ─────────────────────────────────────────────────────

model AuthEvent {
  id          String   @id @default(cuid())
  event_type  String
  subject_id  String
  passport_id String?
  ip_address  String?
  metadata    Json?
  timestamp   DateTime @default(now())

  user        User     @relation(fields: [subject_id], references: [id], onDelete: Cascade)

  @@index([subject_id])
  @@index([event_type])
  @@index([timestamp])
}

// ─── Provider Nodes (onboarded hardware nodes) ───────────────────────────────

enum ProviderTier {
  UNIVERSITY    // .edu institution — reputational stake only
  COMMERCIAL    // Commercial operator — cash/credit stake
}

enum NodeStatus {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
  EJECTED
}

model ProviderNode {
  id                String       @id @default(cuid())
  node_id           String       @unique  // matches agent.node_id
  owner_user_id     String

  // Tier & institution
  tier              ProviderTier @default(COMMERCIAL)
  institution_name  String?      // "MIT", "Stanford CS Dept", etc.
  institution_email String?      // verified .edu email
  mou_signed_at     DateTime?    // MOU timestamp for university tier

  // Hardware fingerprint (collected by install.sh / provider agent)
  gpu_count         Int          @default(0)
  gpu_models        String       @default("[]")  // JSON array
  total_vram_gb     Int          @default(0)
  region            String?

  // Visibility consent (the core T&C)
  visibility_consent_at DateTime?  // timestamp of T&C acceptance
  visibility_scope      String    @default("FULL")  // FULL | PARTIAL

  // Status
  status            NodeStatus   @default(PENDING_VERIFICATION)
  suspended_reason  String?
  trust_score       Float        @default(0)
  uptime_pct_30d    Float?
  last_heartbeat_at DateTime?

  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  stakes            ProviderStake[]
  slash_events      SlashEvent[]

  @@index([owner_user_id])
  @@index([tier])
  @@index([status])
  @@index([node_id])
}

// ─── Mnemo: Stake Engine ──────────────────────────────────────────────────────

enum StakeStatus {
  ACTIVE
  PARTIALLY_SLASHED
  FULLY_SLASHED
  RELEASED
  LOCKED_APPEAL   // frozen while appeal is open
}

model ProviderStake {
  id               String      @id @default(cuid())
  node_id          String
  tier             ProviderTier

  // Amounts (in GP4U credits, USD-pegged 1:1 at launch)
  initial_amount   Decimal     @db.Decimal(12, 4)
  current_amount   Decimal     @db.Decimal(12, 4)
  total_slashed    Decimal     @default(0) @db.Decimal(12, 4)

  status           StakeStatus @default(ACTIVE)
  released_at      DateTime?

  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  node             ProviderNode  @relation(fields: [node_id], references: [node_id], onDelete: Cascade)
  slash_events     SlashEvent[]

  @@index([node_id])
  @@index([status])
}

// ─── Mnemo: Slash Events ──────────────────────────────────────────────────────

enum SlashSeverity {
  WARNING       // logged, no deduction
  SOFT_SLASH    // 10–20% deduction
  HARD_SLASH    // 50–100% deduction + ejection
}

enum SlashCondition {
  // Tier 1 — Warnings
  THERMAL_THROTTLE_EVENT
  UPTIME_DROP_MINOR
  TELEMETRY_DELAY

  // Tier 2 — Soft Slash
  VRAM_OVERCLAIM
  JOB_DROPPED_UNEXPECTEDLY
  UPTIME_SLA_BREACH
  HARDWARE_MISREPRESENTATION
  REPEATED_WARNING

  // Tier 3 — Hard Slash
  TELEMETRY_TAMPERING
  VISIBILITY_BLOCKED        // violated the core T&C
  UNAUTHORIZED_PROCESS
  CRYPTO_MINING_DURING_ML_JOB
  REPEATED_SOFT_SLASH
}

model SlashEvent {
  id               String        @id @default(cuid())
  slash_id         String        @unique @default(cuid())
  node_id          String
  stake_id         String?

  condition        SlashCondition
  severity         SlashSeverity
  description      String

  // Evidence — the raw telemetry/proof is hashed, not stored
  evidence_hash    String        // SHA-256 of raw evidence payload
  evidence_summary String        // human-readable summary for appeals
  ledger_entry_id  String?       // block index in Obsidian ledger

  // Financial impact
  slash_amount     Decimal       @default(0) @db.Decimal(12, 4)
  pct_of_stake     Decimal       @default(0) @db.Decimal(5, 2)

  // Appeal window
  appeal_deadline  DateTime      // slash_at + 7 days
  appealed         Boolean       @default(false)

  // Who issued the slash
  issued_by        String        // admin user_id or "SYSTEM"

  created_at       DateTime      @default(now())

  node             ProviderNode  @relation(fields: [node_id], references: [node_id], onDelete: Cascade)
  stake            ProviderStake? @relation(fields: [stake_id], references: [id])
  appeal           AppealRecord?

  @@index([node_id])
  @@index([condition])
  @@index([severity])
  @@index([created_at])
}

// ─── Mnemo: Appeal Records ────────────────────────────────────────────────────

enum AppealStatus {
  PENDING
  UNDER_REVIEW
  ACCEPTED      // slash reversed, stake restored
  REJECTED      // slash upheld
  EXPIRED       // appeal window passed without filing
}

model AppealRecord {
  id              String       @id @default(cuid())
  appeal_id       String       @unique @default(cuid())
  slash_event_id  String       @unique

  filed_by        String       // node owner user_id
  statement       String       // provider's written appeal
  evidence_urls   String       @default("[]")  // JSON array of supporting URLs

  status          AppealStatus @default(PENDING)
  reviewed_by     String?
  resolution_note String?
  amount_restored Decimal?     @db.Decimal(12, 4)

  filed_at        DateTime     @default(now())
  resolved_at     DateTime?

  slash_event     SlashEvent   @relation(fields: [slash_event_id], references: [id], onDelete: Cascade)

  @@index([slash_event_id])
  @@index([status])
  @@index([filed_by])
}

// ─── ZK Attestation: Proof Registry ──────────────────────────────────────────

enum ProofType {
  HARDWARE_ATTESTATION   // proves job ran on declared hardware
  ENERGY_ATTESTATION     // proves energy consumption for carbon credits
  UPTIME_ATTESTATION     // proves uptime record without revealing customers
}

enum ProofStatus {
  PENDING_VERIFICATION
  VERIFIED
  INVALID
  EXPIRED
}

model ZKProof {
  id              String      @id @default(cuid())
  proof_id        String      @unique @default(cuid())
  node_id         String
  job_id          String?     // null for uptime/energy proofs

  proof_type      ProofType
  status          ProofStatus @default(PENDING_VERIFICATION)

  // The proof itself (serialized; RISC Zero receipt or similar)
  proof_data      String      // base64-encoded proof bytes
  public_inputs   Json        // what the verifier sees: gpu_model, vram_gb, duration_s, etc.
  verification_key String     // identifies the circuit version

  // Timestamps
  generated_at    DateTime
  verified_at     DateTime?
  expires_at      DateTime    // proofs expire after 90 days

  created_at      DateTime    @default(now())

  @@index([node_id])
  @@index([job_id])
  @@index([proof_type])
  @@index([status])
}

// ─── Chamber Registry State ───────────────────────────────────────────────────

model ChamberState {
  id                    String      @id @default(cuid())
  chamber_id            String      @unique
  name                  String
  mode                  ChamberMode @default(PASSIVE)
  events_received       Int         @default(0)
  backtest_score        Float?
  backtest_improvement  Float?
  activated_at          DateTime?
  last_event_at         DateTime?
  last_backtest_at      DateTime?
  error                 String?
  updatedAt             DateTime    @updatedAt

  @@index([chamber_id])
  @@index([mode])
}
